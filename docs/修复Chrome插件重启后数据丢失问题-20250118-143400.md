# 修复Chrome插件重启后数据丢失问题

## 问题描述
用户反馈：首次安装插件并登录后，输入`pp`可以正常唤醒提示词窗口。但关闭浏览器重新打开后，第一次输入`pp`时提示"未找到可用的提示词"，需要再次关闭重新打开浏览器才能恢复正常。

## 问题分析

根据用户描述的现象：
1. 首次安装插件后登录，输入"pp"可以正常唤醒提示词窗口
2. 关闭浏览器重新打开后，输入"pp"提示"未找到可用的提示词"
3. **关键发现：再次关闭并打开浏览器后，问题消失**

通过代码分析，我发现了真正的问题根源：

### 核心问题：Chrome插件生命周期事件的差异化处理

1. **首次安装时**：触发`chrome.runtime.onInstalled`事件
   - 调用`loadDefaultPromptsToMemory()`
   - 检查`hasData()`，如果为false，则加载默认提示词
   - 设置`DEFAULT_TEMPLATES_LOADED = true`
   - 设置`HAS_DATA = true`

2. **第一次重启浏览器时**：触发`chrome.runtime.onStartup`事件
   - 同样调用`loadDefaultPromptsToMemory()`
   - 但此时`hasData()`返回true（因为首次安装时已设置）
   - **关键问题**：函数直接return，不再加载数据
   - 但实际的prompts数据可能因为某种原因未正确持久化

3. **第二次重启浏览器时**：再次触发`chrome.runtime.onStartup`事件
   - 此时数据状态已经稳定，问题消失

### 具体技术原因

1. **数据持久化时序问题**
   - `hasData`标志被设置，但实际的prompts数据可能因为异步操作未完成而丢失
   - Chrome Storage API的异步特性导致状态不一致

2. **初始化逻辑缺陷**
   - `loadDefaultPromptsToMemory`函数过度依赖`hasData()`标志
   - 缺少对实际数据存在性的验证
   - 没有数据修复机制

## 修复方案

基于问题根源分析，需要修复`loadDefaultPromptsToMemory`函数的逻辑缺陷：

### 1. 修复核心初始化逻辑
- **问题**：`hasData()`返回true时直接return，但未验证实际数据是否存在
- **解决方案**：在`hasData()`检查后，额外验证实际prompts数据的存在性
- **实现**：如果prompts数组为空或undefined，重新加载默认数据

### 2. 增强数据完整性检查
- 在每次启动时验证数据的完整性
- 如果发现数据不一致，自动修复
- 添加数据恢复机制

### 3. 优化Chrome Storage API使用
- 确保所有存储操作都正确等待完成
- 添加存储操作的错误处理和重试
- 实现原子性操作，避免部分数据丢失

### 4. 改进错误处理和日志
- 添加详细的初始化过程日志
- 区分不同类型的初始化失败
- 实现优雅的降级处理

### 5. 测试验证
- 模拟浏览器重启场景
- 验证数据持久化的可靠性
- 确保修复后问题不再出现

## 技术实现细节

### 1. 修复loadDefaultPromptsToMemory函数
```javascript
// 修复后的loadDefaultPromptsToMemory函数
async function loadDefaultPromptsToMemory() {
    try {
        // 检查是否已经初始化过
        const hasData = await dataService.hasData();
        
        if (hasData) {
            // 关键修复：验证实际数据是否存在
            const prompts = await dataService.getAllPrompts();
            
            if (prompts && prompts.length > 0) {
                console.log('PromptCraft: Already initialized, prompts count:', prompts.length);
                return;
            } else {
                // 数据标志存在但实际数据为空，需要重新加载
                console.warn('PromptCraft: Data flag exists but prompts are empty, reloading...');
                await dataService.setHasData(false); // 重置标志
            }
        }
        
        console.log('PromptCraft: Loading default prompts...');
        
        // 其余逻辑保持不变...
        const fileUrl = chrome.runtime.getURL('assets/data/default-prompts.json');
        const response = await fetch(fileUrl);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const defaultPrompts = await response.json();
        
        // 确保所有操作都完成后再设置标志
        await dataService.migrateExistingUserData();
        
        const isTemplatesLoaded = await dataService.isDefaultTemplatesLoaded();
        
        if (!isTemplatesLoaded) {
            await dataService.copyDefaultPromptsToUserArea(defaultPrompts);
            await dataService.setDefaultTemplatesLoaded();
        }
        
        // 原子性操作：确保数据和标志同时设置
        await Promise.all([
            dataService.setHasData(true),
            dataService.setThemeMode('auto')
        ]);
        
        console.log('PromptCraft: Initialization completed successfully');
        
    } catch (error) {
        console.error('PromptCraft: Failed to load default prompts:', error);
        
        // 错误处理：设置空数据但确保状态一致
        await Promise.all([
            dataService.setAllPrompts([]),
            dataService.setHasData(true),
            dataService.setLoadError(true, `加载默认提示词失败: ${error.message}`),
            dataService.setThemeMode('auto')
        ]);
    }
}
```

### 2. 增强数据服务的完整性检查
```javascript
// 在DataService中添加数据验证方法
async validateDataConsistency() {
    await this.initialize();
    
    try {
        const hasDataFlag = await this.hasData();
        const actualPrompts = await this.getAllPrompts();
        
        // 检查数据一致性
        if (hasDataFlag && (!actualPrompts || actualPrompts.length === 0)) {
            console.warn('DataService: 检测到数据不一致，hasData=true但prompts为空');
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('DataService: 数据一致性检查失败:', error);
        return false;
    }
}
```

### 3. 优化Chrome Storage操作
```javascript
// 确保存储操作的原子性
async _atomicStorageOperation(operations) {
    try {
        // 将多个存储操作合并为一次操作
        const combinedData = {};
        
        for (const op of operations) {
            Object.assign(combinedData, op);
        }
        
        await this._setToStorage(combinedData);
        console.log('原子性存储操作完成:', Object.keys(combinedData));
        
    } catch (error) {
        console.error('原子性存储操作失败:', error);
        throw error;
    }
}
```

## 预期效果
修复后，用户在浏览器重启后首次使用插件时，将能够：
1. 立即获取到完整的提示词数据
2. 看到友好的加载提示（如果需要等待）
3. 享受稳定一致的用户体验
4. 获得清晰的错误信息（如果出现问题）

## TODO 清单

### 1. [x] **修复loadDefaultPromptsToMemory函数**
   - 在`hasData()`检查后添加实际数据验证
   - 如果数据标志存在但实际数据为空，重新加载默认数据
   - 确保数据和标志的原子性设置
   - 文件位置：`src/background.js`

### 2. [x] **增强DataService数据完整性检查**
   - 添加`validateDataConsistency()`方法
   - 在关键操作前进行数据一致性验证
   - 实现自动数据修复机制
   - 文件位置：`src/utils/data-service.js`

### 3. [x] **优化Chrome Storage操作**
   - 实现原子性存储操作方法`_atomicStorageOperation()`
   - 确保多个相关数据同时更新
   - 添加存储操作的错误处理和重试
   - 文件位置：`src/utils/data-service.js`

### 4. [x] **改进错误处理和日志**
   - 添加详细的初始化过程日志
   - 区分不同类型的初始化失败
   - 实现优雅的降级处理
   - 文件位置：`src/background.js`

### 5. [x] **测试验证**
   - 模拟浏览器重启场景
   - 验证数据持久化的可靠性
   - 确保修复后问题不再出现
   - 测试方法：手动测试 + 控制台日志验证