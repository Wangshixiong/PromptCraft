角色 (Role):
你是一位精通Chrome扩展消息通信和健壮性编程的资深工程师。

核心任务 (Task):
将sidepanel.js中的所有数据写入功能（添加、更新、删除提示词）重构为消息驱动模式。UI不再直接调用dataService，而是向background.js发送命令。

上下文与需求 (Context & Requirements):

【背景】 我们正在进行增量式重构的第二步。第一步（数据读取）已经成功验证了消息通信的可行性。
【核心约束】 本次任务严格限定于addPrompt, updatePrompt, deletePrompt这三个功能的迁移。不要修改authService或syncService的任何逻辑。
【后台background.js的修改】:
在background.js的chrome.runtime.onMessage监听器中，新增对以下三种消息type的处理：
'ADD_PROMPT'
'UPDATE_PROMPT'
'DELETE_PROMPT'
收到消息后，必须调用dataService中对应的函数 (例如，收到'ADD_PROMPT'消息，就调用dataService.addPrompt())，并将操作的payload（数据体）作为参数传递过去。
操作完成后，通过sendResponse返回成功或失败状态，例如{ success: true }或{ success: false, error: error.message }。
【前台sidepanel.js的修改】:
在sidepanel.js中，找到调用dataService.addPrompt, dataService.updatePrompt, dataService.deletePrompt的地方（很可能在savePrompt和deletePrompt这两个事件处理函数中）。
将这些直接调用，完全替换为对应的chrome.runtime.sendMessage调用。
示例: await dataService.addPrompt(newPrompt)应被替换为await chrome.runtime.sendMessage({ type: 'ADD_PROMPT', payload: newPrompt });。
【重要】 因为我们已经有了chrome.storage.onChanged来自动刷新UI，所以在sendMessage成功返回后，不再需要手动调用loadUserPrompts()来刷新界面。